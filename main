// FluidsX.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "iostream"
#include "fstream"
#include "iomanip"
#include "stdlib.h"
#include "time.h"
#include "cmath"
#include "vector"

using namespace std;

fstream finout;

const double h = 0.5;
const double m = 5;
const  int Nx = 15; //横向网格个数
const int Ny = 15; //纵向网格个数
const int N_x = Nx + 2;
const int N_y = Nx + 2;
const int N = N_x*N_y; //总网格个数
const int N0 = 20; //每个网格单元内初态的粒子数
const double Width = 2.0 * h * Nx;
const double Height = 2.0 * h * Ny;
const double Gamma = 0.1; //Gruneisen 系数
const double c0 = 50.100; //声速
const double s = 0.2;
const double alpha = 1.0; //viscosity中的可调参数
const double h_0 = 1.5; //viscosity中的可调参数
const double correction_factor = -0.5; //位置修正系数
const double pi = 3.141592653589793238462643; //圆周率
const double D = 1.0; //力作用常数
const double r0 = 2.0 * h / sqrt(N0); //初始粒子间距
const double e = 0.1;	 //e,a,b is the factors of viscosity;
const double a = 2;
const double b = 2.0;
const double wall_density = 10.0;
const double pumpforce = 10.0;

const time_t t0 = time(NULL);

class vec //矢量类
{
public:
	double x, y; //分量

	vec(const double &X = 0.0, const double &Y = 0.0) //构造函数
	{
		x = X, y = Y;
	}

	double mold() //获取模
	{
		return sqrt(x*x + y*y);
	}

	vec operator +(const vec &v) //加法
	{
		return{ x + v.x, y + v.y };
	}

	vec operator +=(const vec &v) //加法
	{
		*this = *this + v;
		return *this;
	}

	vec operator -(const vec &v) //减法
	{
		return{ x - v.x, y - v.y };
	}

	vec operator -=(const vec &v) //减法
	{
		*this = *this - v;
		return *this;
	}

	vec operator -() //负矢量
	{
		return{ -x, -y };
	}

	vec operator *(const double &k) //数乘
	{
		return{ k*x, k*y };
	}

	vec operator *=(const double &k) //数乘
	{
		*this = (*this) * k;
		return *this;
	}

	vec operator /(const double &k) //数乘
	{
		return{ x / k, y / k };
	}

	vec operator /=(const double &k) //数乘
	{
		*this = (*this) / k;
		return *this;
	}

	double operator *(const vec &v) //点乘
	{
		return x*v.x + y*v.y;
	}

	bool operator ==(const vec &v) //判断相等
	{
		return (x == v.x && y == v.y);
	}
};

vec operator *(const double &k, const vec &r) //数乘
{
	return{ k*r.x, k*r.y };
}

struct particle //粒子结构
{
	vec r, v, a;
	double u, du_dt, pressure, density, density0;
	bool is_wall;
};

vec pump[N] = {};

double W(double rx, double ry) //样条核函数
{
	double W;
	double s = sqrt(rx * rx + ry * ry) / h;
	if (s > 2.0)
		W = 0.0;
	else if (s > 1.0)
		W = 0.25 * (2.0 - s) * (2.0 - s) * (2.0 - s);
	else
		W = 1 - 3 * s*s*(2 - s) / 4;
	return W * 10.0 / (7.0 * pi * h * h);
}

double W(const vec &r) //样条核函数
{
	return W(r.x, r.y);
}

double W(const vec &r1, const vec &r2) //样条核函数
{
	return W(r2.x - r1.x, r2.y - r1.y);
}

vec GradW(double rx, double ry = 0.0) //样条核函数梯度
{
	double GradW;
	double s = sqrt(rx * rx + ry * ry) / h;
	if (s > 2.0)
		GradW = 0.0;
	else if (s > 1.0)
		GradW = -0.75 * (2.0 - s) * (2.0 - s);
	else
		GradW = -3 * s*(4 - 3 * s) / 4;
	return (GradW * 10.0*s / (7.0 * pi * h * h*h*h))*vec(rx, ry);
}

vec GradW(const vec &r) //样条核函数梯度
{
	return GradW(r.x, r.y);
}

vec GradW1(const vec &r1, const vec &r2) //样条核函数梯度
{
	return GradW(r1.x - r2.x, r1.y - r2.y);
}

vec GradW2(const vec &r1, const vec &r2) //样条核函数梯度
{
	return GradW(r2.x - r1.x, r2.y - r1.y);
}

void output(vector<particle> netin[])
{
	int sum = 0;
	for (int nx = 0; nx <= Nx + 1; nx++)
	{
		for (int ny = 0; ny <= Ny + 1; ny++)
			sum += netin[nx + N_x*ny].size();
	}
	finout << sum << endl;
	for (int nx = 0; nx <= Nx + 1; nx++)
	{
		for (int ny = 0; ny <= Ny + 1; ny++)
		{
			for (int i = 0; i < netin[nx + ny*N_x].size(); i++)
			{
				finout << setw(8) << netin[nx + ny*N_x][i].r.x << " "; 
				finout << setw(8) << netin[nx + ny*N_x][i].r.y << " "; 
				finout << setw(8) << netin[nx + ny*N_x][i].v.mold() << endl;
			}
		}
	}
}

int periodicity(int nx, int ny)
{
	return  (nx + Nx - 1) % Nx + 1 + ((ny + Ny - 1) % Ny + 1)*N_x;
}

void periodicity(particle &particlein)
{
	int k = (particlein.r.x < 2.0*h ? 1 : -1);
	while (particlein.r.x<2.0*h || particlein.r.x>Width + 2.0*h)
		particlein.r.x += k*Width;
	k = (particlein.r.y < 2.0*h ? 1 : -1);
	while (particlein.r.y<2.0*h || particlein.r.y>Height + 2.0*h)
		particlein.r.y += k*Height;
}

void setwall(vector<particle> netin[], int nx1, int ny1, int nx2, int ny2)
{
	double x, y;
	if (abs(nx2 - nx1) > abs(ny2 - ny1))
	{
		if (nx2 < nx1) 
		{
			int temp_nx = nx1, temp_ny = ny1;
			nx1 = nx2, ny1 = ny2;
			nx2 = temp_nx, ny2 = temp_ny;
		}
		double k = double(ny2 - ny1) / (nx2 - nx1);
		for (int nx = nx1; nx <= nx2; nx++)
		{
			for (int i = 0; i <= N0; i++)
			{
				x = (2 * nx + 2.0*i / N0)* h;
				y = k*(x - nx1) + ny1;
				netin[nx + int(y)*N_x].push_back({ { x,y } ,{ 0.0,0.0 },{ 0.0,0.0 }, 0.0, 0.0, 0.0, wall_density, wall_density,true });
			}
		}
	}
	else if (ny1 != ny2)
	{
		if (ny2 < ny1)
		{
			int temp_nx = nx1, temp_ny = ny1;
			nx1 = nx2, ny1 = ny2;
			nx2 = temp_nx, ny2 = temp_ny;
		}
		double k = double(nx2 - nx1) / (ny2 - ny1);
		for (int ny = nx1; ny <= ny2; ny++)
		{
			for (int i = 0; i <= N0; i++)
			{
				y = (2 * ny + 2.0*i / N0)* h;
				x = k*(y - ny1) + nx1;
				netin[int(x) + ny*N_x].push_back({ { x,y } ,{ 0.0,0.0 },{ 0.0,0.0 }, 0.0, 0.0, 0.0, wall_density, wall_density,true }); 
			}
		}
	}
}

void setwall(vector<particle> netin[], int nx[], int ny[], int n,char mod='B') 
{
	for (int i = 0; i < n - 1; i++)
		setwall(netin, nx[i], ny[i], nx[i + 1], ny[i + 1]);
	if (n > 2 && mod == 'C')
		setwall(netin, nx[n - 1], ny[n - 1], nx[0], ny[0]);
}

void setpump(int nx1, int ny1, int nx2, int ny2, char mod = 'F', double pump_force = pumpforce)
{
	pump_force /= 2.0;
	if (abs(nx2 - nx1) > abs(ny2 - ny1))
	{
		if (nx2 < nx1)
		{
			int temp_nx = nx1, temp_ny = ny1;
			nx1 = nx2, ny1 = ny2;
			nx2 = temp_nx, ny2 = temp_ny;
			mod = 'F' + 'R' - mod;
		}
		vec force = { double(ny2 - ny1), double(nx1 - nx2) };
		force *= pump_force / force.mold();
		if (mod != 'F')
			force = -force;
		for (int nx = nx1, ny; nx <= nx2; nx++)
		{
			ny = ny1 + (ny2 - ny1) *(nx - nx1) / (nx2 - nx1);
			for (int i = 0; i <= N0; i++)
			{
				pump[nx + ny*N_x] += force;
				pump[periodicity(nx - 1, ny)] += force;
				pump[periodicity(nx + 1, ny)] += force;
				pump[periodicity(nx, ny - 1)] += force;
				pump[periodicity(nx, ny + 1)] += force;
			}
		}
	}
	else if (ny1 != ny2)
	{
		if (ny2 < ny1)
		{
			int temp_nx = nx1, temp_ny = ny1;
			nx1 = nx2, ny1 = ny2;
			nx2 = temp_nx, ny2 = temp_ny;
			mod = 'F' + 'R' - mod;
		}
		vec force = { double(ny2 - ny1), double(nx1 - nx2) };
		force *= pump_force / force.mold();
		if (mod != 'F')
			force = -force;
		for (int ny = nx1, nx; ny <= ny2; ny++)
		{
			nx = nx1 + (nx2 - nx1) *(ny - ny1) / (ny2 - ny1);
			for (int i = 0; i <= N0; i++)
			{
				pump[nx + ny*N_x] += force;
				pump[periodicity(nx - 1, ny)] += force;
				pump[periodicity(nx + 1, ny)] += force;
				pump[periodicity(nx, ny - 1)] += force;
				pump[periodicity(nx, ny + 1)] += force;
			}
		}
	}
}

void setpump(int nx1, int ny1, int nx2, int ny2, vec force)
{
	force /= 2.0;
	if (abs(nx2 - nx1) > abs(ny2 - ny1))
	{
		if (nx2 < nx1)
		{
			int temp_nx = nx1, temp_ny = ny1;
			nx1 = nx2, ny1 = ny2;
			nx2 = temp_nx, ny2 = temp_ny;
		}
		for (int nx = nx1, ny; nx <= nx2; nx++)
		{
			ny = ny1 + (ny2 - ny1) *(nx - nx1) / (nx2 - nx1);
			for (int i = 0; i <= N0; i++) 
			{
				pump[nx + ny*N_x] += force;
				pump[periodicity(nx - 1, ny)] += force; 
				pump[periodicity(nx + 1, ny)] += force; 
				pump[periodicity(nx, ny - 1)] += force; 
				pump[periodicity(nx, ny + 1)] += force; 
			}
		}
	}
	else if (ny1 != ny2)
	{
		if (ny2 < ny1)
		{
			int temp_nx = nx1, temp_ny = ny1;
			nx1 = nx2, ny1 = ny2;
			nx2 = temp_nx, ny2 = temp_ny;
		}
		for (int ny = nx1, nx; ny <= ny2; ny++)
		{
			nx = nx1 + (nx2 - nx1) *(ny - ny1) / (ny2 - ny1);
			for (int i = 0; i <= N0; i++)
			{
				pump[nx + ny*N_x] += force;
				pump[periodicity(nx - 1, ny)] += force;
				pump[periodicity(nx + 1, ny)] += force;
				pump[periodicity(nx, ny - 1)] += force;
				pump[periodicity(nx, ny + 1)] += force;
			}
		}
	}
}

void setgravity(const vec &g) 
{
	for (int i = 0; i < N; i++)
		pump[i] += g;
}

vec boundary(vector<particle> netin[], int i, int m) //边界力
{
	vec netforce = vec(0.0, 0.0);
	if ((i > N_x) && (i < 2 * N_x - 1))
	{
		for (int j = i - N_x - 1; j <= i - N_x + 1; j++)
		{
			for (int k = 0; k < netin[j].size(); k++)
			{
				vec r = netin[i][m].r - netin[j][k].r;
				double rmin = (r.mold() <= 0.3*h ? 0.3*h : r.mold());
				double a = (pow(r0, 4)*pow(rmin, -2) - pow(r0, 2)) / (pow(rmin, 4));
				netforce += D*r*(a > 0 ? a : 0);
			}
		}
	}
	else if ((i > Ny*N_x) && (i < Nx + Ny*N_x - 1))
	{
		for (int j = i + N_x - 1; j <= i + N_x + 1; j++)
		{
			for (int k = 0; k < netin[j].size(); k++)
			{
				vec r = netin[i][m].r - netin[j][k].r;
				double rmin = (r.mold() <= 0.3*h ? 0.3*h : r.mold());
				double a = (pow(r0, 4)*pow(rmin, -2) - pow(r0, 2)) / (pow(rmin, 4));
				netforce += D*r*(a > 0 ? a : 0);
			}
		}
	}
	if (((i - 1) % N_x == 0)/*|| ((i - 2) % N_x==0))&&(((i-1)/N_x)<(0.5*Ny))*/)
	{
		for (int j = i - 1 - N_x; j <= i - 1 + N_x; j += N_x)
		{
			for (int k = 0; k < netin[j].size(); k++)
			{
				vec r = netin[i][m].r - netin[j][k].r;
				double rmin = (r.mold() <= 0.3*h ? 0.3*h : r.mold());
				double a = (pow(r0, 4)*pow(rmin, -2) - pow(r0, 2)) / (pow(rmin, 4));
				netforce += D*r*(a > 0 ? a : 0);
			}
		}
	}
	else if (((i + 2) % N_x == 0))
	{
		for (int j = i + 1 - N_x; j <= i + 1 + N_x; j += N_x)
		{
			for (int k = 0; k < netin[j].size(); k++)
			{
				vec r = netin[i][m].r - netin[j][k].r;
				double rmin = (r.mold() <= 0.3*h ? 0.3*h : r.mold());
				double a = (pow(r0, 4)*pow(rmin, -2) - pow(r0, 2)) / (pow(rmin, 4));
				netforce += D*r*(a > 0 ? a : 0);
			}
		}
	}
	return netforce;
}

double viscosity(particle in1, particle in2)
{
	vec r = in1.r - in2.r;
	vec v = in1.v - in2.v;

	if (r*v >= 0.0)
		return 0.0;
	else
	{
		double density_av = 0.5*(in1.density + in2.density);
		double factor = h*(v*r) / (r*r + e*h*h);
		return (-a*c0*factor + b*factor*factor) / density_av;
	}
}

double pressure(double u, double density, double density0) //压强函数
{
	if (density == 0.0 || density0 == 0.0)
	{
		return 0.0;
	}
	else
	{
		double P_H = c0*c0*(1.0 / density0 - 1.0 / density) / ((1.0 / density0 - s / density0 + s / density) * (1.0 / density0 - s / density0 + s / density));
		double u_H = 0.5*P_H*(1.0 / density0 - 1.0 / density);
		return (P_H + Gamma*density0*(u - u_H));
	}
}

void next(vector<particle> netin[], vector<particle> netout[], double &dt) //函数
{
	int net_i, net_i_size, net_j, net_j_size; 
	particle particlein_i = {}, particlein_j = {};
	double density = 0.0, du_dt = 0.0, P_d2;
	vec a = { 0.0, 0.0 }, P_d2_Grad = { 0.0, 0.0 }, v_correction = { 0.0,0.0 };
	for (int nx = 1; nx <= Nx; nx++)
	{
		for (int ny = 1; ny <= Ny; ny++)
		{
	 		net_i = nx + ny*N_x;
	 		net_i_size = netin[net_i].size();
		 	netout[net_i].resize(net_i_size);
	 		for (int i = 0; i < net_i_size; i++)
	 		{
				particlein_i = netin[net_i][i];
				if (particlein_i.is_wall) 
					netout[net_i][i] = particlein_i;
				else
				{
					a = { 0.0, 0.0 }, P_d2_Grad = { 0.0, 0.0 }, v_correction = { 0.0,0.0 }, density = 0.0, du_dt = 0.0, P_d2 = particlein_i.pressure / (particlein_i.density*particlein_i.density);
					for (int x = nx - 1; x <= nx + 1; x++)
					{
						for (int y = ny - 1; y <= ny + 1; y++)
						{
							net_j = periodicity(x, y);
							net_j_size = netin[net_j].size();
							for (int j = 0; j < net_j_size; j++)
							{
								particlein_j = netin[net_j][j];
								P_d2_Grad = (particlein_j.pressure / (particlein_j.density*particlein_j.density) + P_d2 + viscosity(particlein_j, particlein_i))* GradW1(particlein_i.r, particlein_j.r);
								density += W(particlein_j.r - particlein_i.r);
								du_dt += (particlein_i.v - particlein_j.v)*(P_d2 + 0.5*viscosity(particlein_j, particlein_i))* (GradW1(particlein_i.r, particlein_j.r));
								a += P_d2_Grad;
								v_correction += ((2.0*W(particlein_j.r - particlein_i.r)) / (particlein_i.density + particlein_j.density))*(particlein_i.v - particlein_j.v);
							}
						}
					}
					density *= m, du_dt *= m / 2.0, a = -m*a + pump[net_i];
					netout[net_i][i].density = density;
					netout[net_i][i].du_dt = du_dt;
					netout[net_i][i].u = particlein_i.u + du_dt*dt;
					netout[net_i][i].pressure = pressure(netout[net_i][i].u, density, netin[net_i][i].density0);
					netout[net_i][i].a = a;
					netout[net_i][i].v = particlein_i.v + a*dt;
					v_correction *= correction_factor*m;
					netout[net_i][i].r = particlein_i.r + (2.0*particlein_i.v + a*dt + 2.0*v_correction) *(dt / 2.0);
					netout[net_i][i].is_wall = false;
					periodicity(netout[net_i][i]);
				}
			}
		}
	}
}

void divide(vector<particle> netin[], vector<particle> netout[]) //划分网格
{
	particle particlein_i = {};
	for (int ix = 1; ix <= Nx; ix++)
	{
		for (int iy = 1; iy <= Ny; iy++)
		{
			netout[ix + iy*N_x].clear();
		}
	}
	for (int nx = 1; nx <= Nx; nx++)
	{
		for (int ny = 1; ny <= Ny; ny++)
		{
			for (int i = 0; i < netin[nx + ny*N_x].size(); i++)
			{
				particlein_i = netin[nx + ny*N_x][i];
				netout[(int((particlein_i.r.x) / (2.0 * h))) + (int((particlein_i.r.y) / (2.0 * h)))*N_x].push_back(particlein_i);
			}
		}
	}
}

void initialization(vector<particle> netin[]) //初始化
{
	for (int nx = 1; nx <= Nx; nx++)
	{
		for (int ny = 1; ny <= Ny; ny++)
		{
			netin[nx + ny*N_x].resize(N0);
			for (double k = 0; k < N0; k++)
				//netin[nx + ny*N_x][k] = { { (nx + rand() / (RAND_MAX + 1.0) + (nx == 0 ? 0 : (nx == Nx ? -0.1 : 0.1))) * 2.0 * h , (ny + rand() / (RAND_MAX + 1.0) + (ny == 0 ? 0 : (ny == Ny ? -0.1 : 0.1)))* 2.0 * h } ,{ 10.0,0.0 },{ 0.0,0.0 }, 0.0, 0.0, 0.0, 0.0 };
				netin[nx + ny*N_x][k] = { { (nx + (k + 1) / (N0 + 2)) * 2.0 * h , (ny + (k + 1) / (N0 + 2)) * 2.0 * h } ,{ double(nx - Nx / 2) + 5,0.0 },{ 2.0,0.0 }, 0.0, 0.0, 0.0, 0.0, 0.0,false };
		}
	}
	double density = 0.0;
	for (int nx = 1; nx <= Nx; nx++)
	{
		for (int ny = 1; ny <= Ny; ny++)
		{
			for (int i = 0; i < N0; i++)
			{
				density = 0.0;
				for (int x = nx - 1; x <= nx + 1; x++)
				{
					for (int y = ny - 1; y <= ny + 1; y++)
					{
						for (int j = 0; j < N0; j++)
							density += W(netin[periodicity(x, y)][j].r - netin[nx + ny*N_x][i].r); 
					}
				}
				density *= m;
				netin[nx + ny*N_x][i].density = density;
				netin[nx + ny*N_x][i].pressure = pressure(0.0, density, density);
				netin[nx + ny*N_x][i].density0 = density;
			}
		}
	}
	setwall(netin, 1, 1, Nx, Ny / 3);
	setpump(1, 1, 1, Ny); 
}

int main()
{
	finout.open("D:\out.txt", ios_base::out);
	vector<particle> net1[N], net2[N];
	double dt = 0.001;
	initialization(net1); //初始化	]
	initialization(net2);
	for (int f = 0; f < 10000; f++)
	{
		cout << "frame " << f << " : " << time(NULL) - t0 << 's' << endl;
		//finout << "frame " << f << " : " << time(NULL) - t0 << 's' << endl;
		output(net1);
		next(net1, net2, dt);
		//output(net2);
		//finout << " next " << endl;
		cout << "frame " << f << " after next() : " << time(NULL) - t0 << 's' << endl;
		//finout << "frame " << f << " after next() : " << time(NULL) - t0 << 's' << endl;
		//output(net1);
		divide(net2, net1);
		//output(net1);
		//boundary(net1);
		//	output(net1);
	}
	return 0;
}
