// FluidsX.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "iostream"
#include "fstream"
#include "iomanip"
#include "stdlib.h"
#include "time.h"
#include "cmath"
#include "vector"

using namespace std;

fstream finout;

const double h = 0.05;
const double m = 0.5;
const unsigned int Nx = 80; //横向网格个数
const unsigned int Ny = 80; //纵向网格个数
const unsigned int N_x = Nx + 2;
const unsigned int N_y = Nx + 2;
const unsigned int N = N_x*N_y; //总网格个数
const unsigned int N0 = 10; //每个网格单元内初态的粒子数
const double Width = 2.0 * h * Nx;
const double Height = 2.0 * h * Ny;
const double Gamma = 0.1; //Gruneisen 系数
const double c0 = 1510.0; //声速
const double s = 1.9;
const double pi = 3.141592653589793238462643; //圆周率

const time_t t0 = time(NULL);

class vec //矢量类
{
public:
	double x, y; //分量

	vec(double X = 0.0, double Y = 0.0) //构造函数
	{
		x = X, y = Y;
	}

	vec(const vec &v) //拷贝构造函数
	{
		x = v.x, y = v.y;
	}

	double mold() //获取模
	{
		return sqrt(x*x + y*y);
	}

	vec operator +(const vec &v) //加法
	{
		return{ x + v.x, y + v.y };
	}

	vec operator +=(const vec &v) //加法
	{
		*this = *this + v;
		return *this;
	}

	vec operator -(const vec &v) //减法
	{
		return{ x - v.x, y - v.y };
	}

	vec operator -=(const vec &v) //减法
	{
		*this = *this - v;
		return *this;
	}

	vec operator *(double k) //数乘
	{
		return{ k*x, k*y };
	}

	vec operator *=(double k) //数乘
	{
		*this = (*this) * k;
		return *this;
	}

	vec operator /(double k) //数乘
	{
		return{ x / k, y / k };
	}

	vec operator /=(double k) //数乘
	{
		*this = (*this) / k;
		return *this;
	}

	double operator *(const vec &v) //点乘
	{
		return x*v.x + y*v.y;
	}

	bool operator ==(const vec &v) //判断相等
	{
		return (x == v.x && y == v.y);
	}
};

vec operator -(const vec &v) //负矢量
{
	return{ -v.x, -v.y };
}

vec operator *(double k, const vec &r) //数乘
{
	return{ k*r.x, k*r.y };
}

struct particle //粒子结构
{
	vec r, v, a;
	double u, du_dt, pressure, density;
};

void output(vector<particle> netin[])
{
	finout << "##########" << endl;
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			finout << "netx:" << nx << "  nety:" << ny << "  netsize:" << netin[nx + ny*N_x].size() << endl;
			for (unsigned int i = 0; i < netin[nx + ny*N_x].size(); i++)
			{
				finout << "     x:" << setw(8) << netin[nx + ny*N_x][i].r.x;
				finout << "     y:" << setw(8) << netin[nx + ny*N_x][i].r.y;
				finout << "     vx:" << setw(8) << netin[nx + ny*N_x][i].v.x;
				finout << "     vy:" << setw(8) << netin[nx + ny*N_x][i].v.y << endl;
			}
			finout << endl;
		}
	}
	finout << endl;
}

double W(double rx, double ry = 0) //样条核函数
{
	double W;
	double s = sqrt(rx * rx + ry * ry) / h;
	if (s > 2.0)
		W = 0.0;
	else if (s > 1.0)
		W = 0.25 * (2.0 - s) * (2.0 - s) * (2.0 - s);
	else
		W = 1 - 3 * s*s*(2 - s) / 4; 
	return W * 10.0 / (7.0 * pi * h * h);
}

double W(const vec &r) //样条核函数
{
	return W(r.x, r.y);
}

double W(const vec &r1, const vec &r2) //样条核函数
{
	return W(r2.x - r1.x, r2.y - r1.y);
}

vec GradW(double rx, double ry = 0) //样条核函数梯度
{
	double GradW;
	double s = sqrt(rx * rx + ry * ry) / h;
	if (s > 2.0)
		GradW = 0.0;
	else if (s > 1.0)
		GradW = -0.75 * (2.0 - s) * (2.0 - s);
	else
		GradW = -3 * s*(4 - 3 * s) / 4;
	return (GradW * 10.0*s / (7.0 * pi * h * h*h*h))*vec(rx, ry);
}

vec GradW(const vec &r) //样条核函数梯度
{
	return GradW(r.x, r.y);
}

vec GradW1(const vec &r1, const vec &r2) //样条核函数梯度
{
	return GradW(r1.x - r2.x, r1.y - r2.y);
}

vec GradW2(const vec &r1, const vec &r2) //样条核函数梯度
{
	return GradW(r2.x - r1.x, r2.y - r1.y);
}

double integrate(double(*f)(double), double start, double end, double acc = 1E-6) //通用定积分函数
{
	double mid = (start + end) / 2, inth = end - start, fs = f(start), fe = f(end), fm = f(mid);
	double I = inth * (fs + 4 * fm + fe) / 6;
	double I1 = inth * (fs + 4 * f((start + mid) / 2) + fm) / 12;
	double I2 = inth * (fm + 4 * f((mid + end) / 2) + fe) / 12;
	if (abs(I - I1 - I2) <= acc)
		return I1 + I2;
	else
		return integrate(f, start, mid, acc / 2) + integrate(f, mid, end, acc / 2);
}

double integrate2D(double(*f)(double, double), double xstart, double xend, double ystart, double yend, double acc = 1E-6, char integral = 'a') //通用矩形区域二重积分函数
{
	double halfacc = acc / 2;
	switch (integral) {
	case 'x': {
		if (ystart == yend) {
			double xmid = (xstart + xend) / 2, xinth = xend - xstart, fxs = f(xstart, ystart), fxe = f(xend, ystart), fxm = f(xmid, ystart);
			double Ix = xinth * (fxs + 4 * fxm + fxe) / 6;
			double Ix1 = xinth * (fxs + 4 * f((xstart + xmid) / 2, ystart) + fxm) / 12;
			double Ix2 = xinth * (fxm + 4 * f((xmid + xend) / 2, ystart) + fxe) / 12;
			if (abs(Ix - Ix1 - Ix2) <= acc)
				return Ix1 + Ix2;
			else
				return integrate2D(f, xstart, xmid, ystart, ystart, halfacc, 'x') + integrate2D(f, xmid, xend, ystart, ystart, halfacc, 'x');
		}
	} break;
	case 'y': {
		if (xstart == xend) {
			double ymid = (ystart + yend) / 2, yinth = yend - ystart, fys = f(xstart, ystart), fye = f(xstart, yend), fym = f(xstart, ymid);
			double Iy = yinth * (fys + 4 * fym + fye) / 6;
			double Iy1 = yinth * (fys + 4 * f(xstart, (ystart + ymid) / 2) + fym) / 12;
			double Iy2 = yinth * (fym + 4 * f(xstart, (ymid + yend) / 2) + fye) / 12;
			if (abs(Iy - Iy1 - Iy2) <= acc)
				return Iy1 + Iy2;
			else
				return integrate2D(f, xstart, xstart, ystart, ymid, halfacc, 'y') + integrate2D(f, xstart, xstart, ymid, yend, halfacc, 'y');
		}
	} break;
	default: {
		if (xstart == xend || ystart == yend)
			return 0.0;
		double xmid = (xstart + xend) / 2, xinth = xend - xstart;
		double Ixs = integrate2D(f, xstart, xstart, ystart, yend, halfacc, 'y');
		double Ixe = integrate2D(f, xend, xend, ystart, yend, halfacc, 'y');
		double Ixm = integrate2D(f, xmid, xmid, ystart, yend, halfacc, 'y');
		double I = xinth * (Ixs + 4 * Ixm + Ixe) / 6;
		double I1 = xinth * (Ixs + 4 * integrate2D(f, (xstart + xmid) / 2, (xstart + xmid) / 2, ystart, yend, halfacc, 'y') + Ixm) / 12;
		double I2 = xinth * (Ixm + 4 * integrate2D(f, (xmid + xend) / 2, (xmid + xend) / 2, ystart, yend, halfacc, 'y') + Ixe) / 12;
		if (abs(I - I1 - I2) <= acc)
			return I1 + I2;
		else
			return integrate2D(f, xstart, xmid, ystart, yend, halfacc) + integrate2D(f, xmid, xend, ystart, yend, halfacc);

	} break;
	}
	return 0.0;
}

/*

函数按这样写
void func(vector<particle> netin[], vector<particle> netout[])
{
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			for (unsigned int i = 0; i < netin[nx + ny*N_x].size(); i++)
			{
				for (unsigned int x = nx - 1; x <= nx + 1; x++)
				{
					for (unsigned int y = ny - 1; y <= ny + 1; y++)
					{
						for (unsigned int j = 0; j < netin[x + y*N_x].size(); j++)
						{



						}
					}
				}
			}
		}
	}
}

这样调用
func(net, net_next);

*/

double pressure(double u, double density) //压强函数
{
	double P_H = c0*c0*(1.0 / m - 1.0 / density) / ((1.0 / m - s / m + s / density) * (1.0 / m - s / m + s / density));
	double u_H = 0.5*P_H*(1.0 / m - 1.0 / density);
	return P_H + Gamma*m*(u - u_H);
}

void next(vector<particle> netin[], vector<particle> netout[], double dt) //函数
{
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			double density = 0.0, du_dt = 0.0;
			vec a = { 0.0, 0.0 }, Grad = { 0.0, 0.0 };
			unsigned int size = netin[nx + ny*N_x].size(); 
			netout[nx + ny*N_x].resize(size); 
			for (unsigned int i = 0; i < size; i++)
			{
				a = { 0.0, 0.0 }, Grad = { 0.0, 0.0 }, density = 0.0, du_dt = 0.0;
				for (unsigned int x = nx - 1; x <= nx + 1; x++)
				{
					for (unsigned int y = ny - 1; y <= ny + 1; y++)
					{
						for (unsigned int j = 0; j < netin[x + y*N_x].size(); j++)
						{
							Grad = GradW1(netin[nx + ny*N_x][i].r, netin[x + y*N_x][j].r);
							density += W(netin[x + y*N_x][j].r - netin[nx + ny*N_x][i].r);
							du_dt += (netin[nx + ny*N_x][i].v - netin[x + y*N_x][j].v)*Grad;
							a += Grad;
						}
					}
				}
				netout[nx + ny*N_x][i].density = m*density;
				netout[nx + ny*N_x][i].du_dt = m*netin[nx + ny*N_x][i].pressure*du_dt / (netin[nx + ny*N_x][i].density*netin[nx + ny*N_x][i].density);
				netout[nx + ny*N_x][i].pressure = pressure(netout[nx + ny*N_x][i].u, netout[nx + ny*N_x][i].density);
				netout[nx + ny*N_x][i].u = netin[nx + ny*N_x][i].u + netout[nx + ny*N_x][i].du_dt*dt;
				netout[nx + ny*N_x][i].a = -m*netin[nx + ny*N_x][i].pressure*a / (netin[nx + ny*N_x][i].density*netin[nx + ny*N_x][i].density);
				netout[nx + ny*N_x][i].v = netin[nx + ny*N_x][i].v + netout[nx + ny*N_x][i].a*dt; 
				netout[nx + ny*N_x][i].r = netin[nx + ny*N_x][i].r + (netin[nx + ny*N_x][i].v + netout[nx + ny*N_x][i].v) *(dt / 2.0);
			}
		}
	}
}

void devide(vector<particle> netin[], vector<particle> netout[]) 
{
	for (unsigned int i = 0; i < N;i++)
		netout[i].clear(); 
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			for (unsigned int i = 0; i < netin[nx + ny*N_x].size(); i++)
				netout[int((netin[nx + ny*N_x][i].r.x) / (2.0 * h)) + int((netin[nx + ny*N_x][i].r.y) / (2.0 * h))*N_x].push_back(netin[nx + ny*N_x][i]);
		}
	}
}

void boundary(vector<particle> netin[]) //配置虚粒子
{
	for (unsigned int i = 1; i <= Nx; i++)
	{
		netin[i].resize(netin[i + N_x].size()); 
		for (unsigned int k = 0; k < netin[i + N_x].size(); k++)
		{
			netin[i][k].v.x = netin[i + N_x][k].v.x;
			netin[i][k].v.y = -netin[i + N_x][k].v.y;
			netin[i][k].r.x = netin[i + N_x][k].r.x;
			netin[i][k].r.y = 4 * h - netin[i + N_x][k].r.y;
		}
		netin[i + N - N_x].resize(netin[i + N - 2 * N_x].size()); 
		for (unsigned int k = 0; k < netin[i + N - 2 * N_x].size(); k++)
		{
			netin[i + N - N_x][k].v.x = netin[i + N - 2 * N_x][k].v.x;
			netin[i + N - N_x][k].v.y = -netin[i + N - 2 * N_x][k].v.y;
			netin[i + N - N_x][k].r.x = netin[i + N - 2 * N_x][k].r.x;
			netin[i + N - N_x][k].r.y = (Nx + 1) * 4 * h - netin[i + N - 2 * N_x][k].r.y;
		}
	}
	for (unsigned int j = 0; j <= Ny + 1; j++)
	{
		netin[j*N_x].resize(netin[1 + j*N_x].size()); 
		for (unsigned int k = 0; k < netin[1 + j*N_x].size(); k++)
		{
			netin[j*N_x][k].r.x = 4 * h - netin[1 + j*N_x][k].r.x;
			netin[j*N_x][k].r.y = netin[1 + j*N_x][k].r.y;
			netin[j*N_x][k].v.x = -netin[1 + j*N_x][k].v.x;
			netin[j*N_x][k].v.y = netin[1 + j*N_x][k].v.y; 
		}
		netin[Nx + 1 + j*N_x].resize(netin[Nx + j*N_x].size()); 
		for (unsigned int k = 0; k < netin[Nx + j*N_x].size(); k++)
		{
			netin[Nx + 1 + j*N_x][k].r.x = (Nx + 1) * 4 * h - netin[Nx + j*N_x][k].r.x;
			netin[Nx + 1 + j*N_x][k].r.y = netin[Nx + j*N_x][k].r.y;
			netin[Nx + 1 + j*N_x][k].v.x = -netin[Nx + j*N_x][k].v.x;
			netin[Nx + 1 + j*N_x][k].v.y = netin[Nx + j*N_x][k].v.y;
		}
	}
}

void initialization(vector<particle> netin[]) //初始化
{
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			netin[nx + ny*N_x].resize(N0); 
			for (unsigned int k = 0; k < N0; k++)
				netin[nx + ny*N_x][k] = { { (nx + rand() / (RAND_MAX + 1.0)) * 2.0 * h , (ny + rand() / (RAND_MAX + 1.0)) * 2.0 * h } , { 0.0,0.0 }, { 0.0,0.0 }, 0.0, 0.0, 0.0, 0.0 }; 
		}
	}
	boundary(netin); 
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			double density = 0.0; 
			for (unsigned int i = 0; i < N0; i++)
			{
				density = 0.0;
				for (unsigned int x = nx - 1; x <= nx + 1; x++)
				{
					for (unsigned int y = ny - 1; y <= ny + 1; y++)
					{
						for (unsigned int j = 0; j < N0; j++)
							density += W(netin[x + y*N_x][j].r - netin[nx + ny*N_x][i].r);
					}
				}
				density *= m; 
				netin[nx + ny*N_x][i].density = density; 
				netin[nx + ny*N_x][i].pressure = pressure(0.0, density); 
			}
		}
	}
}

int main()
{
	finout.open("D:\out.txt", ios_base::out); 
	vector<particle> net1[N], net2[N];
	initialization(net1); //初始化
	for (unsigned int f = 0; f < 3; f++)
	{
		cout << "frame " << f << " : " << time(NULL) - t0 << 's' << endl; 
		finout << "frame " << f << " : " << time(NULL) - t0 << 's' << endl;
		output(net1);
		next(net1, net2, 0.001);
		cout << "frame " << f << " after next() : " << time(NULL) - t0 << 's' << endl;
		finout << "frame " << f << " after next() : " << time(NULL) - t0 << 's' << endl;
		output(net1);
		devide(net2, net1);
		cout << "frame " << f << " after devide() : " << time(NULL) - t0 << 's' << endl;
		finout << "frame " << f << " after devide() : " << time(NULL) - t0 << 's' << endl;
		output(net1);
		boundary(net1);
		cout << "frame " << f << " after boundary() : " << time(NULL) - t0 << 's' << endl;
		finout << "frame " << f << " after boundary() : " << time(NULL) - t0 << 's' << endl;
		output(net1);
	}
	return 0;
}
