// FluidsX.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "iostream"
#include "fstream"
#include "iomanip"
#include "stdlib.h"
#include "time.h"
#include "cmath"
#include "vector"

using namespace std;

fstream finout;

const double h = 0.5;
const double m = 5;
const  int Nx = 5; //横向网格个数
const unsigned int Ny = 5; //纵向网格个数
const unsigned int N_x = Nx + 2;
const unsigned int N_y = Nx + 2;
const unsigned int N = N_x*N_y; //总网格个数
const unsigned int N0 = 10; //每个网格单元内初态的粒子数
const double Width = 2.0 * h * Nx;
const double Height = 2.0 * h * Ny;
const double Gamma = 0.1; //Gruneisen 系数
const double c0 = 15.100; //声速
const double s = 0.19;
const double correction_factor = -0.05;//位置修正系数
const double pi = 3.141592653589793238462643; //圆周率
const double D = 0.1;//力作用常数
const double r0 = 2 * h / sqrt(N0);//初始粒子间距

const time_t t0 = time(NULL);

class vec //矢量类
{
public:
	double x, y; //分量

	vec(double X = 0.0, double Y = 0.0) //构造函数
	{
		x = X, y = Y;
	}

	vec(const vec &v) //拷贝构造函数
	{
		x = v.x, y = v.y;
	}

	double mold() //获取模
	{
		return sqrt(x*x + y*y);
	}

	vec operator +(const vec &v) //加法
	{
		return{ x + v.x, y + v.y };
	}

	vec operator +=(const vec &v) //加法
	{
		*this = *this + v;
		return *this;
	}

	vec operator -(const vec &v) //减法
	{
		return{ x - v.x, y - v.y };
	}

	vec operator -=(const vec &v) //减法
	{
		*this = *this - v;
		return *this;
	}

	vec operator *(double k) //数乘
	{
		return{ k*x, k*y };
	}

	vec operator *=(double k) //数乘
	{
		*this = (*this) * k;
		return *this;
	}

	vec operator /(double k) //数乘
	{
		return{ x / k, y / k };
	}

	vec operator /=(double k) //数乘
	{
		*this = (*this) / k;
		return *this;
	}

	double operator *(const vec &v) //点乘
	{
		return x*v.x + y*v.y;
	}

	bool operator ==(const vec &v) //判断相等
	{
		return (x == v.x && y == v.y);
	}
};

vec operator -(const vec &v) //负矢量
{
	return{ -v.x, -v.y };
}

vec operator *(double k, const vec &r) //数乘
{
	return{ k*r.x, k*r.y };
}

struct particle //粒子结构
{
	vec r, v, a;
	double u, du_dt, pressure, density, density0;
};

double W(double rx, double ry) //样条核函数
{
	double W;
	double s = sqrt(rx * rx + ry * ry) / h;
	if (s > 2.0)
		W = 0.0;
	else if (s > 1.0)
		W = 0.25 * (2.0 - s) * (2.0 - s) * (2.0 - s);
	else
		W = 1 - 3 * s*s*(2 - s) / 4;
	return W * 10.0 / (7.0 * pi * h * h);
}

double W(const vec &r) //样条核函数
{
	return W(r.x, r.y);
}

double W(const vec &r1, const vec &r2) //样条核函数
{
	return W(r2.x - r1.x, r2.y - r1.y);
}

vec GradW(double rx, double ry = 0) //样条核函数梯度
{
	double GradW;
	double s = sqrt(rx * rx + ry * ry) / h;
	if (s > 2.0)
		GradW = 0.0;
	else if (s > 1.0)
		GradW = -0.75 * (2.0 - s) * (2.0 - s);
	else
		GradW = -3 * s*(4 - 3 * s) / 4;
	return (GradW * 10.0*s / (7.0 * pi * h * h*h*h))*vec(rx, ry);
}

vec GradW(const vec &r) //样条核函数梯度
{
	return GradW(r.x, r.y);
}

vec GradW1(const vec &r1, const vec &r2) //样条核函数梯度
{
	return GradW(r1.x - r2.x, r1.y - r2.y);
}

vec GradW2(const vec &r1, const vec &r2) //样条核函数梯度
{
	return GradW(r2.x - r1.x, r2.y - r1.y);
}

void output(vector<particle> netin[])
{
	int sum = 0;
	for (unsigned int nx = 0; nx <= Nx + 1; nx++)
	{
		for (unsigned int ny = 0; ny <= Ny + 1; ny++)
		{
			//finout << "netx:" << nx << "  nety:" << ny << "  netsize:" << netin[nx + ny*N_x].size() << endl;
			sum += netin[nx + N_x*ny].size();
		}
	}
	finout << sum << endl;
	for (unsigned int nx = 0; nx <= Nx + 1; nx++)
	{
		for (unsigned int ny = 0; ny <= Ny + 1; ny++)
		{
			//finout << "netx:" << nx << "  nety:" << ny << "  netsize:" << netin[nx + ny*N_x].size() << endl;
			for (unsigned int i = 0; i < netin[nx + ny*N_x].size(); i++)
			{
				//finout << nx << ' ' << ny << ' ' << i;
				finout << /*"     x:"  <<*/ setw(8) << netin[nx + ny*N_x][i].r.x << " ";
				finout << /*"     y:"  <<*/ setw(8) << netin[nx + ny*N_x][i].r.y << " ";
				//finout << setw(8) << netin[nx + ny*N_x][i].pressure << " "<< netin[nx + ny*N_x][i].density<<" "<< netin[nx + ny*N_x][i].u<<' ';
				//finout /*<< "     vx:"*/ << setw(8) << netin[nx + ny*N_x][i].v.x;
				//finout /*<< "     vy:" */<< setw(8) << netin[nx + ny*N_x][i].v.y << endl;
				finout << setw(8) << netin[nx + ny*N_x][i].v.mold() << endl;
			}
		}
	}
}

/*void boundary(vector<particle> netin[]) //配置虚粒子
{
for (unsigned int i = 1; i <= Nx; i++)
{
netin[i].resize(netin[i + N_x].size());
for (unsigned int k = 0; k < netin[i + N_x].size(); k++)
{
netin[i][k].v.x = netin[i + N_x][k].v.x;
netin[i][k].v.y = -netin[i + N_x][k].v.y;
netin[i][k].r.x = netin[i + N_x][k].r.x;
netin[i][k].r.y = 4 * h - netin[i + N_x][k].r.y;
netin[i][k].density = netin[i + N_x][k].density;
netin[i][k].density0 = netin[i + N_x][k].density0;
netin[i][k].pressure = netin[i + N_x][k].pressure;
}
netin[i + N - N_x].resize(netin[i + N - 2 * N_x].size());
for (unsigned int k = 0; k < netin[i + N - 2 * N_x].size(); k++)
{
netin[i + N - N_x][k].v.x = netin[i + N - 2 * N_x][k].v.x;
netin[i + N - N_x][k].v.y = -netin[i + N - 2 * N_x][k].v.y;
netin[i + N - N_x][k].r.x = netin[i + N - 2 * N_x][k].r.x;
netin[i + N - N_x][k].r.y = (Nx + 1) * 4 * h - netin[i + N - 2 * N_x][k].r.y;
netin[i + N - N_x][k].density = netin[i + N - 2 * N_x][k].density;
netin[i + N - N_x][k].density0 = netin[i + N - 2 * N_x][k].density0;
netin[i + N - N_x][k].pressure = netin[i + N - 2 * N_x][k].pressure;
}
}
for (unsigned int j = 0; j <= Ny + 1; j++)
{
netin[j*N_x].resize(netin[1 + j*N_x].size());
for (unsigned int k = 0; k < netin[1 + j*N_x].size(); k++)
{
netin[j*N_x][k].r.x = 4 * h - netin[1 + j*N_x][k].r.x;
netin[j*N_x][k].r.y = netin[1 + j*N_x][k].r.y;
netin[j*N_x][k].v.x = -netin[1 + j*N_x][k].v.x;
netin[j*N_x][k].v.y = netin[1 + j*N_x][k].v.y;
netin[j*N_x][k].density = netin[1 + j*N_x][k].density;
netin[j*N_x][k].density0 = netin[1 + j*N_x][k].density0;
netin[j*N_x][k].pressure = netin[1 + j*N_x][k].pressure;
}
netin[Nx + 1 + j*N_x].resize(netin[Nx + j*N_x].size());
for (unsigned int k = 0; k < netin[Nx + j*N_x].size(); k++)
{
netin[Nx + 1 + j*N_x][k].r.x = (Nx + 1) * 4 * h - netin[Nx + j*N_x][k].r.x;
netin[Nx + 1 + j*N_x][k].r.y = netin[Nx + j*N_x][k].r.y;
netin[Nx + 1 + j*N_x][k].v.x = -netin[Nx + j*N_x][k].v.x;
netin[Nx + 1 + j*N_x][k].v.y = netin[Nx + j*N_x][k].v.y;
netin[Nx + 1 + j*N_x][k].density = netin[Nx + j*N_x][k].density;
netin[Nx + 1 + j*N_x][k].density0 = netin[Nx + j*N_x][k].density0;
netin[Nx + 1 + j*N_x][k].pressure = netin[Nx + j*N_x][k].pressure;
}
}
}*/

void boundaryini(vector<particle> netin[])
{
	for (unsigned int i = 1; i <= Nx; i++)
	{
		for (unsigned int k = 0; k < N0 * 10; k++)
		{
			netin[i].push_back({ { (i + k / (N0 * 10)) * 2.0 * h,2.0 * h },{ 0,0 },{ 0,0 }, 0, 0, 0, 0, 0 });
			netin[N - N_x + i - 1].push_back({ { (i + k / (N0 * 10.0)) * 2.0 * h,(Ny + 1) * 2 * h },{ 0,0 },{ 0,0 }, 0, 0, 0, 0, 0 }); 
		}
	}
	for (unsigned int i = 0; i <= Ny + 1; i++)
	{
		for (unsigned int k = 0; k < N0 * 10; k++)
		{
			netin[N_x*i].push_back({ { 2.0 * h, (i + k / (N0 * 10)) * 2.0 * h } ,{ 0,0 },{ 0,0 },0,0,0,0,0 });
			netin[N_x*i + Nx + 1].push_back({ { (Nx + 1) * 2.0 * h, (i + k / (N0 * 10.0)) * 2.0 * h } ,{ 0,0 },{ 0,0 },0,0,0,0,0 });
		}
	}
}

vec boundary(vector<particle> netin[], unsigned int i, unsigned int m) //边界力
{
	vec netforce = vec(0.0, 0.0);
	if (i > N_x&&i < 2 * N_x - 1)
	{
		for (unsigned int j = i - N_x - 1; j <= i - N_x + 1; j++)
		{
			for (unsigned int k = 0; k < netin[j].size(); k++)
			{
				double r = (netin[i][m].r - netin[j][k].r).mold();
				netforce += D*r*(pow(r0, 4)*pow(r, -2) - pow(r0, 2)) / (pow(r, 4)); 
			}
		}
	}
	else if (i > Ny*N_x&&i < Nx + Ny*N_x - 1)
	{
		for (unsigned int j = i + N_x - 1; j <= i + N_x + 1; j++)
		{
			for (unsigned int k = 0; k < netin[j].size(); k++)
			{
				double r = (netin[i][m].r - netin[j][k].r).mold();
				netforce += D*r*(pow(r0, 4)*pow(r, -2) - pow(r0, 2)) / (pow(r, 4));
			}
		}
	}
	if ((i - 1) % N_x == 0)
	{
		for (unsigned int j = i - 1 - N_x; j <= i - 1 + N_x; j += N_x)
		{
			for (unsigned int k = 0; k < netin[j].size(); k++)
			{
				double r = (netin[i][m].r - netin[j][k].r).mold();
				netforce += D*r*(pow(r0, 4)*pow(r, -2) - pow(r0, 2)) / (pow(r, 4));
			}
		}
	}
	else if ((i + 2) % N_x == 0)
	{
		for (unsigned int j = i + 1 - N_x; j <= i + 1 + N_x; j += N_x)
		{
			for (unsigned int k = 0; k < netin[j].size(); k++)
			{
				double r = (netin[i][m].r - netin[j][k].r).mold();
				netforce += D*r*(pow(r0, 4)*pow(r, -2) - pow(r0, 2)) / (pow(r, 4));
			}
		}
	}
	return netforce; 
}

double pressure(double u, double density, double density0) //压强函数
{
	if (density == 0.0 || density0 == 0.0) 
	{
		return 0;
	}
	else
	{
		double P_H = c0*c0*(1.0 / density0 - 1.0 / density) / ((1.0 / density0 - s / density0 + s / density) * (1.0 / density0 - s / density0 + s / density)); 
		double u_H = 0.5*P_H*(1.0 / density0 - 1.0 / density);
		return (P_H + Gamma*density0*(u - u_H));
	}
}

void next(vector<particle> netin[], vector<particle> netout[], double &dt) //函数
{
	unsigned int size;
	double dtmin = 2.0*h*(Nx > Ny ? Nx : Ny) / c0, tempdt; 
	particle particleini = {}, particleouti = {};
	double density = 0.0, du_dt = 0.0, P_d2;
	vec a = { 0.0, 0.0 }, P_d2_Grad = { 0.0, 0.0 }, v_correction = { 0.0,0.0 };
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			size = netin[nx + ny*N_x].size();
			netout[nx + ny*N_x].resize(size);
			for (unsigned int i = 0; i < size; i++)
			{
				particleini = netin[nx + ny*N_x][i], a = { 0.0, 0.0 }, P_d2_Grad = { 0.0, 0.0 }, v_correction = { 0.0,0.0 }, density = 0.0, du_dt = 0.0, P_d2 = particleini.pressure / (particleini.density*particleini.density), tempdt = 2.0*h*(Nx > Ny ? Nx : Ny) / c0; 
				for (unsigned int x = (nx == 1 ? 1 : nx - 1); x <= (nx == Nx ? nx : Nx); x++)
				{
					for (unsigned int y = (ny == 1 ? 1 : ny - 1); y <= (ny == Ny ? ny : Ny); y++)
					{
						//finout <<nx<<' '<<ny<<' '<<i<<' '<<x<<' '<<y<<' '<< netin[x + y*N_x][0].pressure / (netin[x + y*N_x][0].density*netin[x + y*N_x][0].density) << ' ' << P_d2 << "!!!" << endl;
						for (unsigned int j = 0; j < netin[x + y*N_x].size(); j++)
						{
							//finout << nx << ' ' << ny << ' ' << i <<' '<<j<<' ' << x << ' ' << y << ' ' << netin[x + y*N_x][j].pressure/* / (netin[x + y*N_x][j].density*netin[x + y*N_x][j].density)*/ << ' ' << P_d2 << "!!!" << endl;
							P_d2_Grad = (netin[x + y*N_x][j].pressure / (netin[x + y*N_x][j].density*netin[x + y*N_x][j].density) + P_d2)* GradW1(particleini.r, netin[x + y*N_x][j].r);
							density += W(netin[x + y*N_x][j].r - particleini.r);
							du_dt += (netin[x + y*N_x][j].v - particleini.v)*P_d2_Grad;
							a += P_d2_Grad;
							v_correction += ((2.0*W(netin[x + y*N_x][j].r - particleini.r)) / (particleini.density + netin[x + y*N_x][j].density))*(netin[x + y*N_x][j].v - particleini.v);
							//cout << P_d2_Grad.x << ' ' << P_d2_Grad.y << endl;
						}
					}
				}
				density *= m, du_dt *= m / 2.0, a = -m*a + boundary(netin, nx + ny*N_x, i); 
				netout[nx + ny*N_x][i].density = density;
				netout[nx + ny*N_x][i].du_dt = du_dt;
				netout[nx + ny*N_x][i].u = particleini.u + du_dt*dt;
				netout[nx + ny*N_x][i].pressure = pressure(netout[nx + ny*N_x][i].u, density, netin[nx + ny*N_x][i].density0);
				//finout<<nx<<' ' <<ny <<' '<<i<<' '<< f.mold();
				netout[nx + ny*N_x][i].a = a;
				//finout <<' ' << a.mold() <<endl;
				netout[nx + ny*N_x][i].v = particleini.v + a*dt; 
				v_correction *= correction_factor*m;
				netout[nx + ny*N_x][i].r = particleini.r + (2.0*particleini.v + a*dt + 2.0*v_correction) *(dt / 2.0);		
				if (netout[nx + ny*N_x][i].v.x > 0.0) 
					tempdt = (2.0*h*(N_x - 1) - netout[nx + ny*N_x][i].r.x) / netout[nx + ny*N_x][i].v.x;
				else if (netout[nx + ny*N_x][i].v.x < 0.0) 
					tempdt = -(netout[nx + ny*N_x][i].r.x - 2.0*h) / netout[nx + ny*N_x][i].v.x; 
				dtmin = (dtmin > tempdt ? tempdt : dtmin);
				if (netout[nx + ny*N_x][i].v.y > 0.0)
					tempdt = (2.0*h*(N_y - 1) - netout[nx + ny*N_x][i].r.y) / netout[nx + ny*N_x][i].v.y;
				else if (netout[nx + ny*N_x][i].v.x < 0.0)
					tempdt = -(netout[nx + ny*N_x][i].r.y - 2.0*h) / netout[nx + ny*N_x][i].v.y;
				dtmin = (dtmin > tempdt ? tempdt : dtmin);
			}
		}
	}
	dt = dtmin;
}

void divide(vector<particle> netin[], vector<particle> netout[]) //划分网格
{
	for (int ix = 1; ix <= Nx; ix++)
	{
		for (int iy = 1; iy <= Ny; iy++)
		{
			netout[ix + iy*N_x].clear();
		}
	}
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			for (unsigned int i = 0; i < netin[nx + ny*N_x].size(); i++)
			{
				//finout << "before " << netin[nx + ny*N_x][i].r.x << ' ' << netin[nx + ny*N_x][i].r.y << endl;
				double x = (netin[nx + ny*N_x][i].r.x) / (2.0 * h);
				double y = (netin[nx + ny*N_x][i].r.y) / (2.0 * h);
				//finout << "divide " << x << ' ' << y<<endl;
				if (x <= 1 || x >= (Nx + 1) || y <= 1 || y >= (Ny + 1))
				{
					//netin[Nx/2 + N_x*Ny / 2].push_back({{100.0,0.0},{0.0,0.0}, {0.0,0.0},1.0,1.0,1.0,1.0,1.0});
				}
				else 
					netout[(int(x)) + (int(y))*N_x].push_back(netin[nx + ny*N_x][i]); 
			}
		}
	}
}

void initialization(vector<particle> netin[]) //初始化
{
	for (int nx = 1; nx <= Nx; nx++)
	{
		for (int ny = 1; ny <= Ny; ny++)
		{
			netin[nx + ny*N_x].resize(N0);
			for (double k = 0; k < N0; k++)
				netin[nx + ny*N_x][k] = { { (nx + rand() / (RAND_MAX + 1.0) + (nx == 0 ? 0 : (nx == Nx ? -0.1 : 0.1))) * 2.0 * h , (ny + rand() / (RAND_MAX + 1.0) + (ny == 0 ? 0 : (ny == Ny ? -0.1 : 0.1)))* 2.0 * h } ,{ 10.0,0.0 },{ 0.0,0.0 }, 0.0, 0.0, 0.0, 0.0 };
			//netin[nx + ny*N_x][k] = { { (nx +(k+1)/(N0+2)) * 2.0 * h , (ny + (k + 1) / (N0 + 2)) * 2.0 * h } ,{double(nx-Nx/2)+5,0.0 },{ 2.0,0.0 }, 0.0, 0.0, 0.0, 0.0, 0.0 };
		}
	}
	boundaryini(netin);
	double density = 0.0;
	for (unsigned int nx = 1; nx <= Nx; nx++)
	{
		for (unsigned int ny = 1; ny <= Ny; ny++)
		{
			for (unsigned int i = 0; i < N0; i++)
			{
				density = 0.0;
				/*for (unsigned int x = nx - 1; x <= nx + 1; x++)
				{
				for (unsigned int y = ny - 1; y <= ny + 1; y++)*/
				for (unsigned int x = (nx == 1 ? 1 : nx - 1); x <= (nx == Nx ? nx : Nx); x++)
				{
					for (unsigned int y = (ny == 1 ? 1 : ny - 1); y <= (ny == Ny ? ny : Ny); y++)
					{
						for (unsigned int j = 0; j < N0; j++)
							density += W(netin[x + y*N_x][j].r - netin[nx + ny*N_x][i].r);
					}
				}
				density *= m;
				netin[nx + ny*N_x][i].density = density;
				netin[nx + ny*N_x][i].pressure = pressure(0.0, density, density);
				netin[nx + ny*N_x][i].density0 = density;
			}
		}
	}
}

int main()
{
	finout.open("D:\out.txt", ios_base::out);
	vector<particle> net1[N], net2[N];
	double dt = 0.001;
	initialization(net1); //初始化	]
	initialization(net2);
	for (unsigned int f = 0; f < 10000; f++)
	{
		cout << "frame " << f << " : " << time(NULL) - t0 << 's' << endl;
		//finout << "frame " << f << " : " << time(NULL) - t0 << 's' << endl;
		output(net1);
		next(net1, net2, dt); 
		//output(net2);
		//finout << " next " << endl;
		cout << "frame " << f << " after next() : " << time(NULL) - t0 << 's' << endl;
		//finout << "frame " << f << " after next() : " << time(NULL) - t0 << 's' << endl;
		//output(net1);
		divide(net2, net1);
		//output(net1);
		//boundary(net1);
		//	output(net1);
	}
	return 0;
}
